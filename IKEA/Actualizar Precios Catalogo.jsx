#target "indesign"#targetengine "medianis"#strict on// http://extendables.org/#include "lib/lib_codigos.jsx"var NOMBRE_COLOR_OK = "CAMBIADO";function crearColor(doc, nombre, rgb){    var color = doc.colors.itemByName(nombre);    if (color != null) return color    return doc.colors.add( { name:nombre, colorValue:rgb } );}function UITable(values) {    var rce = """palette {                     orientation:'row', alignChildren:'fill',                     text: 'TABLA PRECIOS',                     preferredSize:[600, 620],                    mainPanel: Panel {                        alginment:'fill',                        alignChildren:'fill',                        table : ListBox {                             preferredSize:[590, 605],                             properties:{ numberOfColumns:5, showHeaders:true, columnTitles:["Código", "Actual", "Esperado", "Actualizar", "Página"],                            columnWidths:[130, 130, 130, 130, 60], },                         },                    },                  }""";    var wnd = new Window(rce);        var sortedValues = values.sort(function(a, b) {         var a_page = (a[4].parentTextFrames && a[4].parentTextFrames[0].parentPage) ? Number(a[4].parentTextFrames[0].parentPage.name) : 0;        var b_page = (b[4].parentTextFrames && b[4].parentTextFrames[0].parentPage) ? Number(b[4].parentTextFrames[0].parentPage.name) : 0;                    if (a_page < b_page) return -1;        else if (a_page > b_page) return 1;        else return 0;     }); // Use custom comparator        sortedValues.forEach( function(v) {        var row = wnd.mainPanel.table.add('item', v[0]);        row.subItems[0].text = v[1];        row.subItems[1].text = v[2] || '';        row.subItems[2].text = v[3] || '';        try {            row.subItems[3].text = v[4].parentTextFrames[0].parentPage.name;        } catch(e) {};    });    wnd.mainPanel.table.onDoubleClick = function () {         if (this.selection && this.selection.subItems[3].text != "") {             app.select(app.activeDocument.pages[Number(this.selection.subItems[3].text)-1]);             app.activeWindow.zoom(ZoomOptions.FIT_PAGE);        }    };    wnd.show();}function extractCodePricePairs(doc, pg){    var pairs = [];        var tf = textFramesGrep(doc, rePrice, pg);        pg && pg.setMax(tf.length);    pg && pg.show("Códigos encontrados");        tf.forEach(function(textFrame) {        pairs = pairs.concat(getIKEACodePricePairs(textFrame));        pg && pg.step("Códigos encontrados: " + pairs.length.toString());    });    return pairs.sort(function(a, b) {         if (a[0] < b[0]) return -1;        else if (a[0] > b[0]) return 1;        else return 0;     }); // Use custom comparator}function mkUnique(arr, item_i) {    var new_arr = [];        var i = item_i ? item_i : 0;        var set = {};    arr.forEach( function(row) {         if (set[row[i]] == undefined) {            new_arr.push(row);                    set[row[i]] = true;        }    } );    set = null;    return new_arr;}function mkObject(arr, item_i) {    var Obj = {};    var i = item_i ? item_i : 0;        arr.forEach( function(row) { Obj[ row[i] ] = row; } );    return Obj;}/* Se genera un fichero csv con la siguiente extructura:        código; precio en indesign; precio original; precio actualizar;*         donde el '*' es una marca que aparece cuando precio en indesign no         coincide con precio original */function saveTableToFile(file, table, unique, show) {    var dst = file ? File(file) : File.saveDialog("Indicar fichero de destino");    var f_dst = File(dst);        f_dst.encoding = "UTF-8";    f_dst.open("w");    f_dst.writeln("CAMBIOS REALIZADOS");    f_dst.writeln("Código;Precio Indesign;Precio Original;Precio Actualizar;Página");    var w_sep = function(/* dst, sep, row0, row1, ... */){        var dst = arguments[0];        var sep = arguments[1];        var rst = arguments;                for (var i=2, e=rst.length-1; i<e; ++i) // i=2 -> ignore first two arguments            dst.write(rst[i] + sep);        dst.writeln(rst[i]);            }    var tableF = unique ? mkUnique(table) : table;    tableF.forEach( function(row) {         w_sep(f_dst, ';',             row[0], row[1], row[2] || '', row[3] || '', (row[4].parentTextFrames[0]) ? row[4].parentTextFrames[0].parentPage.name : "");    });    tableF = undefined;    f_dst.close();        if (show)        f_dst.execute();}    function saveDataToCSV(fileName, data, sepBy) {    var sep = sepBy ? sepBy : ";";        var file = File(fileName);    file.open("w");    data.forEach( function(cp) {        if (cp)            file.writeln(cp.join(sep));    } );    file.close();}function loadDataFromFile(fileName, sepBy) {    """Lee la información de código;precio;precio desde un archivo csv       Se puede especificar el separador (por defecto ';').              - Se presupone que el primer precio es el actual (a cambiar) y         el segundo precio es el nuevo (a actualizar).                - Detecta si el archivo tiene cabecera y la ignora              - Ignora aquellas filas que no tengan precio a actualizar    """    var sep = sepBy || ";";        var file = File(fileName);    file.open();        var data = [];    while (! file.eof ) {        var line = file.readln().split(sep);                if (line[0] == '' || !parseInt(line[0]) || line[2] == '')            continue;                var item = [];        for (var i=0; i<line.length; ++i)             item.push(line[i]);        data.push( item );    }        file.close();        return data;}function filterCode(codePricePairs, code, i) {    var r = codePricePairs[codeToNumber(code)];    if (r)         return r[i];    else         return "";}function changeColor(doc, word) {    var colorCAMBIO = crearColor(doc, NOMBRE_COLOR_OK, [75, 0, 100, 0]);        word.fillColor = colorCAMBIO;}function updatePrices(doc, table, pg) {    var colorCAMBIO = crearColor(doc, NOMBRE_COLOR_OK, [75, 0, 100, 0]);        pg && pg.show("Actualizando precios");    pg && pg.setMax(table.length);    table.forEach( function(row) {        pg && pg.step("Actualizando precios: " + row[0]);        var ps = priceSplit(row[1]);        var add_ceros = ps[1].indexOf('.00') >= 0 ? /(\.|\,)\d+/.exec(row[1])[0] : '';        var match = ps[0] + row[3] + add_ceros;        var price = row[5];                changeColor(doc, price);        if (price.contents.toString().indexOf('/') >= 0)            price.contents = match + '/' + price.contents.toString().split('/')[1];        else            price.contents = match;    });}function colorDonePrices(doc, table) {    table.forEach( function(row) {        var match = row[3];        var price = row[5];                changeColor(doc, price);    });}function markAsError(doc, table, pg) {    var colorCAMBIO = crearColor(doc, "ERROR", [0, 100, 100, 0]);        pg && pg.show("Códigos precio no coincide");    pg && pg.setMax(table.length);    table.forEach( function(row) {        pg && pg.step("Códigos precio no coincide: " + row[0]);        row[5].fillColor = colorCAMBIO;    });}function matchCode(codePricePairs, code) {    """Busca dentro de la lista (objeto) de códigos precio el código indicado"""    var r = codePricePairs[codeToNumber(code)];    if (r)         return r[i];    else         return "";}function main() {    var pg = ProgressBar(0, "Generando listado de códigos y precio del documento")    var forg = File.openDialog ("Fichero con precios originales");    if (!forg) return ;        pg.show("Cargando lista de precios originales");        // El fichero de precios originales ha de tener la siguiente estructura: "código;precio original;precio actualizado"    var referenceTable = mkObject(loadDataFromFile(forg));        if (referenceTable) {        // relación de códigos y precios en el documento actual en formato [codigo, precio, Object Word (codigo), Object Word precio]        var table = extractCodePricePairs(app.activeDocument, pg)                  .filter( function(row) {                       return row[2].characters[0].fillColor.name != NOMBRE_COLOR_OK;                   } );                // Tabla extendida -> [código, precio en página, precio de referencia, precio nuevo, Object Word (codigo), Object Word precio]        var xTable = table.map( function(row) {            var prices = referenceTable[row[0]] || "";            return [row[0], row[1],                     prices[1],                     prices[2],                    row[2], row[3]];        });            table = null;        referenceTable = null;                // Valido si, habiendo precio anterior, coincide con el precio en página        var check = function(row) {             return !!row[0]  // hay código                && !!row[3]  // hay nuevo precio                && (  !row[2]  // no hay precio anterior                   || priceToNumber(row[1]) === priceToNumber(row[2]) );  // o si lo hay, coincide con el de página        }                // Crea una Objeto con aquellos productos que coinciden        var matchingPrices = [];        // Crea una tabla con aquellos productos EN LOS QUE NO COINCIDE        var wrongPrices = [];        // Probablemente ya actualizados        var donePrices = [];                xTable.forEach( function(row) {            if (check(row))                matchingPrices.push(row);            else if (priceToNumber(row[1]) === priceToNumber(row[3]))                donePrices.push(row);            else                wrongPrices.push(row);        } );                xTable = null;                // HACE LA ACTUALIZACIÓN DE PRECIOS        updatePrices(app.activeDocument, matchingPrices, pg);        colorDonePrices(app.activeDocument, donePrices);        if (wrongPrices && wrongPrices.length > 0) {            UITable(mkUnique(wrongPrices));            saveTableToFile('~/CodigoPrecios_error.csv', wrongPrices, true, false);        }        saveTableToFile('~/CodigoPrecios.csv', matchingPrices, false, true);        matchingPrices = null;        wrongPrices = null;    }    pg.close();}function prepareCodePriceFile() {    var codigo_precio_nuevo = loadDataFromFile(File.openDialog ("Fichero de precios nuevos"));    var codigo_precio_ref   = mkObject(loadDataFromFile(File.openDialog ("Fichero de precios referencia")));    var codigo_precio = codigo_precio_nuevo.map( function(cp) {        var code = cp[0];        var ref = codigo_precio_ref[code];        if (ref) {            var precio_ref   = ref[1].indexOf('.') >= 0 ? ref[1] : ref[1] + '.00';            var precio_nuevo = cp[1].indexOf('.') >= 0 ? cp[1] : cp[1] + '.00';                        return [ code, precio_ref, precio_nuevo ];         }    });    codigo_precio_nuevo = null;    codigo_precio_ref = null;    saveDataToCSV(File.saveDialog ("Fichero destino"), codigo_precio);    codigo_precio = null;}// main();// prepareCodePriceFile();app.doScript(main,    ScriptLanguage.JAVASCRIPT   , null  , UndoModes.ENTIRE_SCRIPT  , 'Actualizar Precios');