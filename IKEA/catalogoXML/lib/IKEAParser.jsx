/** IKEA Catalogo XML    Author: Javier Ramos    ==== Parser Module ====    */#strict on// Extends IKEA module with a submodule for styling capabilitiesIKEA.Parser = (function() {    var self = this;        var exported = { name:'IKEA submodule: Parser' };        exported.Colors = ['azul', 'azul', 'beige', 'blanco', 'blanco', 'niquelado', 'blekinge', 'cuadros',                       'dansbo', 'gris', 'grisáceo', 'idemo', 'isunda', 'marrón', 'multicolor',                        'natural', 'negro', 'norraby', 'oscuro', 'plata', 'risane', 'rojo',                        'rutna', 'svanby', 'tullinge', 'sivik', 'verde', 'lindö', 'korndal', 'husie',                        'naranja', 'grann', 'turquesa', 'bambú'                      ];                          exported.is_color = function(txt) {        var res = exported.Colors.contains(txt.toLowerCase());                          if (!res && txt.indexOf('/') > -1){            txt.split('/').each(function(t) {                res |= exported.Colors.contains(t.toLowerCase());            });        }                if (!res && txt.indexOf('-') > -1){            txt.split('-').each(function(t) {                res |= exported.Colors.contains(t.toLowerCase());            });        }        return res;    };    exported.is_measure = function(txt) {        return ["altura", "ancho", "densidad", "largo", "alto", "máxima",                "mínima", "diámetro", "fondo", "grosor", "longitud", "profundidad"               ].contains(txt.toLowerCase())             || !!txt.match(/\d+.*”/)            || !!txt.match(/cm/)               ;    };    exported.product_fields = [IKEA.CF_FORMATNUMBER, IKEA.CF_NAME, IKEA.CF_FACTS,                               IKEA.CF_PRICENORMAL, IKEA.CF_COLOR, IKEA.CF_SIZE,                               IKEA.CF_ALMCOD, IKEA.CF_CUSTBENEFIT, "numbered"];                                                                            exported.Product = function ParserProduct(partNumber, name, description, price, color, measure, almcod, info) {        var self = this;        this.fields_ = exported.product_fields;        this.values_ = {};                var fn_aux = function(fname) {             try {                eval(fname) && self.values_[fname] = eval(fname);             } catch(e) { return ; }        }        this.fields_.each(function(field) { fn_aux(field); });                this.get = function(fname, withTitle) {            """Returns the value of a field (optionally with the field name)."""            if (self.fields_.indexOf(fname) === -1) {                throw new TypeError(                    "Field {} don't exists in IKEA.Parser.Product".format(fname)                );            }            var v = self.values_[fname] || "";             if (v && withTitle) {                 v = fname + ': ' + v;             }            return v;         }         this.set = function(fname, value) {            """Set a new value for a field in the object. Return the old value."""            if (self.fields_.indexOf(fname) === -1) {                throw new TypeError(                    "Field {} don't exists in IKEA.Parser.Product".format(name)                );            }            var res = self.values_[fname];            if (value) {                self.values_[fname] = value;            }            return res;        };                this.print = function(lineSep) {            if (!lineSep) { lineSep = '\n'; }                        $.writeln("---------------------------------");            $.writeln(self.fields_.map(function(field) {                return self.get(field, true);             }).filter(function(v) {                 return v != '';             }).join(lineSep));        }                return this;    }    exported.parseTextFrame = function(tframe) {        if (!tframe || tframe.constructor.name !== 'TextFrame') {            throw new TypeError("parseTextFrame except a TextFrame!");        }        var state = { last_pn: null,                      last_txt: null,                      product: new exported.Product(),                      key: "numbered",                      assign: function(p, pn) {                           this.last_pn = pn;                           this.product.set(IKEA.CF_PARTNUMBER, pn);                          p[pn] = this.product;                          // Reset product                          this.product = new exported.Product();                           this.key = "numbered";                      },                      add: function(k, v) {                          this.product.set(                            k, (state.product.get(k) + ' ' + v).trim()                          );                          this.key = k;                      }                    }                        var products = {};        _extend_collection(tframe, 'Words');                tframe.words.map(function(w){            state.last_txt = txt;            var txt = w.contents.toString();            if (w.appliedCharacterStyle.name === IKEA.Styles.ALMCODE && state.last_pn) {                    products[state.last_pn].set(IKEA.CF_ALMCOD, txt);            } else if (w.appliedFont.fontStyleName.toLowerCase() === 'bold') {                isNumber = !isNaN(Number(txt));                if (state.key === 'numbered' && isNumber) {                    state.add('numbered', txt);                } else if (txt === txt.toUpperCase()                            && !isNumber                            && ['numbered', IKEA.CF_NAME].contains(state.key))                 {                    state.add(IKEA.CF_NAME, txt);                } else if (IKEA.RE_PRICE.test(txt)                           && [IKEA.CF_FACTS, IKEA.CF_PRICENORMAL].contains(state.key))                 {                    state.add(IKEA.CF_PRICENORMAL, txt);                } else {                    state.add(IKEA.CF_FACTS, txt);                }            } else {                if (IKEA.RE_LARGECODE.test(txt)) {                    var pn = txt.match(IKEA.RE_LARGECODE)[0];                    state.assign(products, pn);                } else if (exported.is_color(txt)) {                    state.add(IKEA.CF_COLOR, txt);                } else if (exported.is_measure(txt))                 {                    state.add(IKEA.CF_MEASURE, txt);                } else {                     state.add(IKEA.CF_CUSTBENEFIT, txt);                }            }        });        return products;    }    exported.Form = function() {        var buttonStyle     = 'preferredSize: [120, 24]';        var buttonStyleMini = 'preferredSize: [24, 24]';        var def_h = 24;        var sizes_ = {};            sizes_[IKEA.CF_PARTNUMBER] = [200, def_h];            sizes_[IKEA.CF_NAME] = [240, def_h];            sizes_[IKEA.CF_FACTS] = [340, def_h];            sizes_[IKEA.CF_PRICENORMAL] = [200, def_h];            sizes_[IKEA.CF_COLOR] = [140, def_h];            sizes_[IKEA.CF_MEASURE] = [200, def_h];            sizes_[IKEA.CF_ALMCOD] = [60, def_h];            sizes_[IKEA.CF_CUSTBENEFIT] = [440, def_h];                var wr = """dialog {             alignChildren: 'fill',            mPanel: Panel {                alignChildren: 'left',            },            bottomGroup: Group {                alignment: 'fill',                bUpdate: Button { text:'Actulizar', preferredSize: [140, 24] }                bClose   : Button { text:'Cerrar', preferredSize: [140, 24] }            }        }""".replace(/#buttonStyle#/g, buttonStyle).replace(/#buttonStyleMini#/g, buttonStyleMini);                var wnd = new Window(wr);                wnd.fields = {};        wnd.cancelElement = wnd.bottomGroup.bClose;                exported.product_fields                .filter(function(field) { return field !== 'numbered'; })                .each(function(field) {            var g = wnd.mPanel.add('group')            g.add('statictext', undefined, IKEA.labels[field]);            wnd.fields[field] = g.add('edittext');            wnd.fields[field].preferredSize = sizes_[field];        });        wnd.showProduct = function(product) {            exported.product_fields                    .filter(function(field) { return field !== 'numbered'; })                    .each(function(l) {                wnd.fields[l].text = product.get(l);            });            wnd.show();        };        return wnd;    };    return exported;})();