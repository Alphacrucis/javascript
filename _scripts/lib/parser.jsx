#strict on// http://extendables.org/#include "/Volumes/DS/medianis/_scripts/frameworks/stdbrouw-Extendables-b315665/extendables.jsx"function grammar(description, whitespace)/*  Convert a description to a grammar.  Each line is a rule for a    non-terminal symbol; it looks like this:        Symbol =>  A1 A2 ... | B1 B2 ... | C1 C2 ...    where the right-hand side is one or more alternatives, separated by    the '|' sign.  Each alternative is a sequence of atoms, separated by    spaces.  An atom is either a symbol on some left-hand side, or it is    a regular expression that will be passed to re.match to match a token.        Notation for *, +, or ? not allowed in a rule alternative (but ok    within a token). Use '\' to continue long lines.  You must include spaces    or tabs around '=>' and '|'. That's within the grammar description itself.    The grammar that gets defined allows whitespace between tokens by default;    specify '' as the second argument to grammar() to disallow this (or supply    any regular expression to describe allowable whitespace between tokens).    */{    if (!whitespace) whitespace = """\s*""";    G = {' ':whitespace};    description = description.replace(/\t/gm, ' ') // no tabs!    desc ription.split('\n').forEach( function(line) {        rp = line.split(' => ');        lhs = rp[0];        rhs = rp[1];        alternatives = rhs.split(' | ')        G[lhs] = alternatives.map(Array.prototype.split); // <---- SINTAXIS PYTHON, CAMBIAR!!!    } );    return G;}function parse(start_symbol, text, grammar)/*  Example call: parse('Exp', '3*x + b', G).    Returns a (tree, remainder) pair. If remainder is '', it parsed the whole    string. Failure iff remainder is None. This is a deterministic PEG parser,    so rule order (left-to-right) matters. Do 'E => T op E | T', putting the    longest parse first; don't do 'E => T | T op E'    Also, no left recursion allowed: don't do 'E => E op T'    */{    tokenizer = grammar[' '] + '(%s)';        parse_sequence = function(sequence, text) {        result = [];        sequence.forEach( function(atom) {            rp = parse_atom(atom, text);            tree = rp[0];            text = rp[1];            if (!text) return null;            result.append(tree);        } );        return [result, text];    }    parse_atom = function(atom, text) {        if (atom in grammar)        {            grammar[atom].forEach( function(alternative) {                rp = parse_sequence(alternative, text)                tree = rp[0];                rem = rp[1];                if (!rem) return [[atom]+tree, rem];            } );            return null;        }        else {  // Terminal: match characters against start of text            m = re.match(tokenizer.replace('(%s)', atom), text);            return (!m) ? null : (m.group(1), text.slice(m.end())); // <---- SINTAXIS PYTHON, CAMBIAR!!!        }    }        // Body of parse:    return parse_atom(start_symbol, text);}var testGrammar = """Exp => Term [+-] Exp | TermTerm => Var | NumVar => [a-zA-Z_]\w*Num => [-+]?[1-9][0-9]*""";var Grammar = grammar(testGrammar);$.writeln(parse('Exp', "x + 1", testGrammar));